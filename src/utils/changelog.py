# ============================================================================ #
#                                                                              #
#     Title: Generate Changelog for GitHub Repository                          #
#     Purpose: Generate a changelog for a GitHub repository by fetching        #
#              release tags and their associated commit messages.              #
#                                                                              #
# ============================================================================ #


# ---------------------------------------------------------------------------- #
#                                                                              #
#     Setup                                                                 ####
#                                                                              #
# ---------------------------------------------------------------------------- #


## --------------------------------------------------------------------------- #
##  Imports                                                                 ####
## --------------------------------------------------------------------------- #


# ## Python StdLib Imports ----
import os
import re
from pathlib import Path
from typing import Literal, Optional

# ## Python Third Party Imports ----
from github import Auth, Github
from github.Auth import Token
from github.Commit import Commit
from github.GithubObject import NotSet
from github.GitRelease import GitRelease
from github.Repository import Repository


## --------------------------------------------------------------------------- #
##  Constants                                                               ####
## --------------------------------------------------------------------------- #


### Environment Variables ----
TOKEN: Optional[str] = os.environ.get("GITHUB_TOKEN")
REPOSITORY_NAME: Optional[str] = os.environ.get("REPOSITORY_NAME")
if TOKEN is None:
    raise RuntimeError("Environment variable `GITHUB_TOKEN` is not set. Please set it before running the script.")
if REPOSITORY_NAME is None:
    raise RuntimeError("Environment variable `REPOSITORY_NAME` is not set. Please set it before running the script.")


### Static ----
OUTPUT_FILENAME: Literal["CHANGELOG.md"] = "CHANGELOG.md"
OUTPUT_FILEPATH: Path = Path(OUTPUT_FILENAME)
AUTH: Token = Auth.Token(TOKEN)
NEW_LINE: Literal["\n"] = "\n"
BLANK_LINE: Literal["\n\n"] = "\n\n"
LINE_BREAK: Literal["<br>"] = "<br>"
TAB: Literal["    "] = "    "


# ---------------------------------------------------------------------------- #
#                                                                              #
#     Functions                                                             ####
#                                                                              #
# ---------------------------------------------------------------------------- #


## --------------------------------------------------------------------------- #
##  Output                                                                  ####
## --------------------------------------------------------------------------- #


def prepare_output_file() -> None:
    """
    Prepare the output file by deleting it if it exists and creating a new one.
    This ensures that the output file is always fresh and does not contain any
    old data from previous runs.
    """
    # NOTE: We want to re-create the output file every time we run the script,
    # so here we will delete it even if it does exist and generate a whole new one.

    # Delete the output file if it exists
    if OUTPUT_FILEPATH.exists():
        OUTPUT_FILEPATH.unlink()

    # Create a new output file
    OUTPUT_FILEPATH.touch()


def add_page_styling() -> str:
    """
    Generate the page styling for the changelog.
    This function returns a string containing the CSS styles to be applied to the changelog page.
    The styles are used to hide the nested navigation lists in the Markdown navigation.
    """
    return (
        f"<style>{NEW_LINE}"
        f".md-nav--secondary .md-nav__list .md-nav__item {{ display: block; padding-bottom: 0.5em; }}{NEW_LINE}"
        f".md-nav--secondary .md-nav__list .md-nav__list {{ display: none; }}{NEW_LINE}"
        f"</style>{BLANK_LINE}"
    )


def add_header(repo: Repository) -> str:
    """
    Generate the header for the changelog.
    This function returns a string containing the header information, including the repository name,
    origin URL, and API URL. The header is formatted as HTML comments to provide metadata about the changelog.
    """
    return (
        f"<!-- !This file is auto-generated. Do not edit this file manually! -->{NEW_LINE}"
        f"{NEW_LINE}"
        f"<!-- repo='{repo.full_name}' -->{NEW_LINE}"
        f"<!-- origin_url='{repo.html_url}' -->{NEW_LINE}"
        f"<!-- api_url='{repo.url}' -->{NEW_LINE}"
        f"{NEW_LINE}"
    )


def add_release_info(release: GitRelease, repo: Repository) -> str:
    """
    Generate the release information for a given GitHub release.
    This function returns a string containing the formatted release information,
    including the release tag, date, link, and body.
    """
    return (
        f'!!! info "{release.tag_name}"{NEW_LINE}'
        f"{NEW_LINE}"
        f"{TAB}## **{release.name}**{BLANK_LINE}"
        f"{TAB}<!-- md:tag {release.tag_name} -->{LINE_BREAK}{NEW_LINE}"
        f"{TAB}<!-- md:date {release.created_at.date()} -->{LINE_BREAK}{NEW_LINE}"
        f"{TAB}<!-- md:link [{repo.full_name}/releases/{release.tag_name}]({release.html_url}) -->{BLANK_LINE}"
    )


def add_release_notes(release: GitRelease) -> str:
    """
    Generate the release notes for a given GitHub release.
    This function returns a string containing the formatted release notes,
    including the release body and any additional information.
    """
    release_body: str = (
        release.body.replace(f"{BLANK_LINE}", NEW_LINE).replace("## ", "### ").replace(NEW_LINE, f"{TAB * 2}")
    )
    return f'{TAB}??? note "Release Notes"{BLANK_LINE}' f"{TAB * 2}{release_body}{BLANK_LINE}"


def add_commit_info(commit: Commit) -> str:
    """
    Generate the commit information for a given GitHub commit.
    This function returns a string containing the formatted commit information,
    including the commit message, author, and link to the commit.
    """
    # NOTE: We write the commit message to the output file.
    # We format the commit message to replace newlines with `{LINE_BREAK}` tags for better readability in Markdown.
    # We also include the author's login and a link to their GitHub profile, as well as a link to the commit itself.

    commit_message_list: list[str] = []
    for idx, line in enumerate(commit.commit.message.split(NEW_LINE)):
        if idx == 0:
            commit_message_list.append(line.strip())
        elif line.strip() == "":
            continue
        elif line.lower().startswith("co-authored-by:"):
            continue
        else:
            commit_message_list.append(line.strip())

    commit_message_str: str = "\n".join(commit_message_list)
    commit_message_str: str = commit_message_str.replace(NEW_LINE, f"{LINE_BREAK}{NEW_LINE}{TAB * 3}")

    return (
        f"{TAB * 2}* [`{commit.sha[:7]}`]({commit.html_url}): {commit_message_str}"
        f"{NEW_LINE}"
        f"{TAB * 3}(by [{commit.author.login if commit.author else ''}]({commit.author.html_url if commit.author else ''}))"
        f"{NEW_LINE}"
    )


# ---------------------------------------------------------------------------- #
#                                                                              #
#     Main Section                                                          ####
#                                                                              #
# ---------------------------------------------------------------------------- #


def main() -> None:
    """
    Main function to generate the changelog for the GitHub repository.
    It prepares the output file, connects to GitHub, fetches the releases,
    and writes the changelog to the output file.
    """

    # NOTE: The reason why we use a context manager here is to ensure that the GitHub connection is properly terminated and the file is properly closed after we are finished processing; even if an error occurs during the process.
    # Also, here we can also open both contexts in the same line; which is syntactically cleaner and more efficient.

    ### Open the contexts ----
    with Github(auth=AUTH) as g, open(OUTPUT_FILENAME, "w") as f:

        ### Get the repository ----
        REPO: Repository = g.get_repo(REPOSITORY_NAME)  # type: ignore

        ### Write the header to the output file ----
        f.write(add_header(REPO))

        ### Prepare the output file ----
        f.write(add_page_styling())

        ### Fetch the releases for the repository, sorted by reverse creation date ----
        releases: list[GitRelease] = sorted(
            REPO.get_releases(),
            key=lambda r: r.created_at,
            reverse=True,
        )

        ### Loop through the releases ----
        for index, release in enumerate(releases):

            # NOTE: We need to determine if the previous tag exists.
            # If `index + 1 < len(releases)`, then we can fetch the previous release's tag name.
            # Otherwise, we set the previous tag to `"0"` to indicate that there is no previous tag.
            # This is done to ensure that we can fetch the commits between the current release and the previous release.
            # If there is no previous release, we fetch all commits until the current release. This is the case for the very first release in the repo.

            ### Determine the previous tag if it exists, otherwise set it to "0"
            previous_tag: str = releases[index + 1].tag_name if index + 1 < len(releases) else "0"

            ### Write the release information to the output file ----
            f.write(add_release_info(release, REPO))

            ### Add a section for release notes ----
            f.write(add_release_notes(release))

            ### Add a section for updates ----
            f.write(f'{TAB}??? abstract "Updates"{BLANK_LINE}')

            # NOTE: We fetch the commits between the current release and the previous release.
            # If the previous tag is "0", we fetch all commits until the current release.
            # Otherwise, we fetch commits since the previous release's creation date until the current release's creation date.

            ### Fetch the commits for the current release ----
            commits: list[Commit] = sorted(
                REPO.get_commits(
                    since=(releases[index + 1].created_at if previous_tag != "0" else NotSet),
                    until=release.created_at,
                ),
                key=lambda c: c.commit.committer.date,
                reverse=True,
            )

            ### Loop through the commits ----
            for commit in commits:

                # NOTE: We skip commits that are not relevant for the changelog.
                # Specifically, we skip merge commits, commits that update the coverage report, and commits that update the changelog itself.
                # This is done to ensure that the changelog only contains relevant changes made to the codebase.

                ### Skip irrelevant commits ----
                if re.search(
                    r"Merge|Bump|Update coverage report|Update changelog",
                    commit.commit.message,
                ):
                    continue

                ### Write the commit message to the output file ----
                f.write(add_commit_info(commit))

            ### Add a newline after each release section ----
            f.write(f"{BLANK_LINE}")

    ### Once file is written, run `blacken-docs` on it ----
    os.system(f"blacken-docs {OUTPUT_FILENAME}")


# ---------------------------------------------------------------------------- #
#                                                                              #
#     Execute                                                               ####
#                                                                              #
# ---------------------------------------------------------------------------- #


if __name__ == "__main__":
    main()
